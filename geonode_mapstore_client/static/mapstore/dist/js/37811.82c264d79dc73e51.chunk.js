(self.webpackChunkgeonode_mapstore_client=self.webpackChunkgeonode_mapstore_client||[]).push([[37811],{492078:(e,t,s)=>{var n=s(514528),r=s(983120),i=s(423007),o=s(956449);e.exports=function(){var e=arguments.length;if(!e)return[];for(var t=Array(e-1),s=arguments[0],h=e;h--;)t[h-1]=arguments[h];return n(o(s)?i(s):[s],r(t,1))}},85890:(e,t,s)=>{"use strict";s.d(t,{A:()=>y});var n=s(332135),r=s(506837),i=s(821409),o=s(495902),h=s(88280),a=s(374238),l=s(570915),u=s(206933),g=s(934142),c=s(207434),d=s(104087),_=s(209438);function f(e){return e.feature?e.feature:e.element?e.element:null}const m=[];class p extends i.A{constructor(e){const t=e=e||{};t.handleDownEvent||(t.handleDownEvent=a.rT),t.stopDown||(t.stopDown=a.W8),super(t),this.source_=e.source?e.source:null,this.vertex_=void 0===e.vertex||e.vertex,this.edge_=void 0===e.edge||e.edge,this.features_=e.features?e.features:null,this.featuresListenerKeys_=[],this.featureChangeListenerKeys_={},this.indexedFeaturesExtents_={},this.pendingFeatures_={},this.pixelTolerance_=void 0!==e.pixelTolerance?e.pixelTolerance:10,this.rBush_=new o.A,this.GEOMETRY_SEGMENTERS_={Point:this.segmentPointGeometry_.bind(this),LineString:this.segmentLineStringGeometry_.bind(this),LinearRing:this.segmentLineStringGeometry_.bind(this),Polygon:this.segmentPolygonGeometry_.bind(this),MultiPoint:this.segmentMultiPointGeometry_.bind(this),MultiLineString:this.segmentMultiLineStringGeometry_.bind(this),MultiPolygon:this.segmentMultiPolygonGeometry_.bind(this),GeometryCollection:this.segmentGeometryCollectionGeometry_.bind(this),Circle:this.segmentCircleGeometry_.bind(this)}}addFeature(e,t){t=void 0===t||t;const s=(0,d.v6)(e),n=e.getGeometry();if(n){const t=this.GEOMETRY_SEGMENTERS_[n.getType()];if(t){this.indexedFeaturesExtents_[s]=n.getExtent((0,l.S5)());const r=[];if(t(r,n),1===r.length)this.rBush_.insert((0,l.Tr)(r[0]),{feature:e,segment:r[0]});else if(r.length>1){const t=r.map((e=>(0,l.Tr)(e))),s=r.map((t=>({feature:e,segment:t})));this.rBush_.load(t,s)}}}t&&(this.featureChangeListenerKeys_[s]=(0,_.KT)(e,r.A.CHANGE,this.handleFeatureChange_,this))}getFeatures_(){let e;return this.features_?e=this.features_:this.source_&&(e=this.source_.getFeatures()),e}handleEvent(e){const t=this.snapTo(e.pixel,e.coordinate,e.map);return t&&(e.coordinate=t.vertex.slice(0,2),e.pixel=t.vertexPixel),super.handleEvent(e)}handleFeatureAdd_(e){const t=f(e);t&&this.addFeature(t)}handleFeatureRemove_(e){const t=f(e);t&&this.removeFeature(t)}handleFeatureChange_(e){const t=e.target;if(this.handlingDownUpSequence){const e=(0,d.v6)(t);e in this.pendingFeatures_||(this.pendingFeatures_[e]=t)}else this.updateFeature_(t)}handleUpEvent(e){const t=Object.values(this.pendingFeatures_);return t.length&&(t.forEach(this.updateFeature_.bind(this)),this.pendingFeatures_={}),!1}removeFeature(e,t){const s=void 0===t||t,n=(0,d.v6)(e),r=this.indexedFeaturesExtents_[n];if(r){const t=this.rBush_,s=[];t.forEachInExtent(r,(function(t){e===t.feature&&s.push(t)}));for(let e=s.length-1;e>=0;--e)t.remove(s[e])}s&&((0,_.JH)(this.featureChangeListenerKeys_[n]),delete this.featureChangeListenerKeys_[n])}setMap(e){const t=this.getMap(),s=this.featuresListenerKeys_,r=this.getFeatures_();t&&(s.forEach(_.JH),s.length=0,this.rBush_.clear(),Object.values(this.featureChangeListenerKeys_).forEach(_.JH),this.featureChangeListenerKeys_={}),super.setMap(e),e&&(this.features_?s.push((0,_.KT)(this.features_,n.A.ADD,this.handleFeatureAdd_,this),(0,_.KT)(this.features_,n.A.REMOVE,this.handleFeatureRemove_,this)):this.source_&&s.push((0,_.KT)(this.source_,h.A.ADDFEATURE,this.handleFeatureAdd_,this),(0,_.KT)(this.source_,h.A.REMOVEFEATURE,this.handleFeatureRemove_,this)),r.forEach((e=>this.addFeature(e))))}snapTo(e,t,s){const n=s.getView().getProjection(),r=(0,c.Ad)(t,n),i=(0,c.JR)((0,l.r)((0,l.Tr)([r]),s.getView().getResolution()*this.pixelTolerance_),n),o=this.rBush_.getInExtent(i),h=o.length;if(0===h)return null;let a,g=1/0;const d=this.pixelTolerance_*this.pixelTolerance_,_=()=>{if(a){const t=s.getPixelFromCoordinate(a);if((0,u.hG)(e,t)<=d)return{vertex:a,vertexPixel:[Math.round(t[0]),Math.round(t[1])]}}return null};if(this.vertex_){for(let e=0;e<h;++e){const t=o[e];"Circle"!==t.feature.getGeometry().getType()&&t.segment.forEach((e=>{const t=(0,c.Ad)(e,n),s=(0,u.hG)(r,t);s<g&&(a=e,g=s)}))}const e=_();if(e)return e}if(this.edge_){for(let e=0;e<h;++e){let t=null;const s=o[e];if("Circle"===s.feature.getGeometry().getType()){let e=s.feature.getGeometry();const i=(0,c.Tf)();i&&(e=e.clone().transform(i,n)),t=(0,u.hw)(r,e)}else{const[e,i]=s.segment;i&&(m[0]=(0,c.Ad)(e,n),m[1]=(0,c.Ad)(i,n),t=(0,u.sG)(r,m))}if(t){const e=(0,u.hG)(r,t);e<g&&(a=(0,c.te)(t,n),g=e)}}const e=_();if(e)return e}return null}updateFeature_(e){this.removeFeature(e,!1),this.addFeature(e,!1)}segmentCircleGeometry_(e,t){const s=this.getMap().getView().getProjection();let n=t;const r=(0,c.Tf)();r&&(n=n.clone().transform(r,s));const i=(0,g.nD)(n);r&&i.transform(s,r);const o=i.getCoordinates()[0];for(let t=0,s=o.length-1;t<s;++t)e.push(o.slice(t,t+2))}segmentGeometryCollectionGeometry_(e,t){const s=t.getGeometriesArray();for(let t=0;t<s.length;++t){const n=this.GEOMETRY_SEGMENTERS_[s[t].getType()];n&&n(e,s[t])}}segmentLineStringGeometry_(e,t){const s=t.getCoordinates();for(let t=0,n=s.length-1;t<n;++t)e.push(s.slice(t,t+2))}segmentMultiLineStringGeometry_(e,t){const s=t.getCoordinates();for(let t=0,n=s.length;t<n;++t){const n=s[t];for(let t=0,s=n.length-1;t<s;++t)e.push(n.slice(t,t+2))}}segmentMultiPointGeometry_(e,t){t.getCoordinates().forEach((t=>{e.push([t])}))}segmentMultiPolygonGeometry_(e,t){const s=t.getCoordinates();for(let t=0,n=s.length;t<n;++t){const n=s[t];for(let t=0,s=n.length;t<s;++t){const s=n[t];for(let t=0,n=s.length-1;t<n;++t)e.push(s.slice(t,t+2))}}}segmentPointGeometry_(e,t){e.push([t.getCoordinates()])}segmentPolygonGeometry_(e,t){const s=t.getCoordinates();for(let t=0,n=s.length;t<n;++t){const n=s[t];for(let t=0,s=n.length-1;t<s;++t)e.push(n.slice(t,t+2))}}}const y=p}}]);